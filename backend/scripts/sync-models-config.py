#!/usr/bin/env python3
"""
Sync model configuration from backend to frontend
This ensures we have a single source of truth for model availability
"""

import json
from pathlib import Path
from config import BEDROCK_MODELS, get_available_models_for_chat

def get_display_name(full_name: str) -> str:
    """Extract a concise display name with version from the full model name"""
    if 'Claude 4' in full_name:
        if 'Opus' in full_name:
            return 'Claude 4 Opus'
        else:
            return 'Claude 4 Sonnet'
    elif 'Claude 3.7' in full_name:
        return 'Claude 3.7 Sonnet'
    elif 'Claude 3.5' in full_name:
        return 'Claude 3.5 Haiku'
    elif 'Nova Premier' in full_name:
        return 'Nova Premier'
    elif 'Nova Micro' in full_name:
        return 'Nova Micro'
    else:
        # Fallback to last word
        return full_name.split()[-1]

def sync_models_to_frontend():
    """Export model configuration to a format the frontend can use"""
    
    # Get project root
    project_root = Path(__file__).parent.parent.parent
    
    # Prepare model data for frontend
    frontend_models = {}
    
    # Get available models for chat
    chat_models = get_available_models_for_chat()
    chat_model_names = [m['name'] for m in chat_models]
    
    for model_key, model_config in BEDROCK_MODELS.items():
        # Determine which modes this model supports
        supported_modes = []
        
        # Agent mode now supports Claude 3.7 Sonnet (as configured)
        if model_key == 'claude-3-7-sonnet':
            supported_modes = ['chat', 'agent']
        # Other models only work in chat mode if they're in the available list
        elif model_key in chat_model_names:
            supported_modes = ['chat']
        
        # Skip models that aren't available in any mode
        if not supported_modes:
            continue
            
        frontend_models[model_key] = {
            'id': model_config['id'],
            'name': model_config['name'],
            'displayName': get_display_name(model_config['name']),  # Better display name with version
            'description': model_config['description'],
            'cost': model_config['cost'],
            'speed': model_config['speed'],
            'inferenceProfile': model_config.get('inference_profile'),
            'available': True,
            'supportedModes': supported_modes
        }
    
    # Create the TypeScript configuration file
    ts_content = """// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
// This file is generated by backend/scripts/sync-models-config.py
// To update models, edit backend/scripts/config.py and run sync-models-config.py

export interface BedrockModel {
  id: string
  name: string
  displayName: string
  description: string
  cost: string
  speed: string
  inferenceProfile: string | null
  available: boolean
  supportedModes: ('chat' | 'agent')[]
}

export const BEDROCK_MODELS: Record<string, BedrockModel> = """ + json.dumps(frontend_models, indent=2) + """

export const getAvailableModels = (mode: 'chat' | 'agent' | 'all' = 'all'): BedrockModel[] => {
  return Object.entries(BEDROCK_MODELS)
    .filter(([_, model]) => {
      if (mode === 'all') return model.available
      return model.available && model.supportedModes.includes(mode)
    })
    .map(([key, model]) => ({ ...model, key }))
}

export const getDefaultModel = (mode: 'chat' | 'agent'): string => {
  return mode === 'agent' ? 'claude-3-7-sonnet' : 'claude-3-7-sonnet'
}

export const AGENT_MODEL_NOTE = 'Note: Agent mode uses Claude 3.7 Sonnet. Model selection in agent mode is for display only - the actual model is configured in AWS Console.'
"""
    
    # Write to lib directory
    models_config_path = project_root / 'lib' / 'models-config.ts'
    models_config_path.write_text(ts_content)
    
    print(f"‚úÖ Exported model configuration to {models_config_path}")
    print(f"üìã Models available:")
    for key, model in frontend_models.items():
        modes = ', '.join(model['supportedModes'])
        print(f"   - {model['name']} ({key}): {modes}")
    
    # Also update the API route to use the same data
    api_models_content = """import { NextRequest, NextResponse } from 'next/server'
import { BEDROCK_MODELS, getAvailableModels, getDefaultModel, AGENT_MODEL_NOTE } from '@/lib/models-config'

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url)
    const mode = searchParams.get('mode') as 'chat' | 'agent' | 'all' || 'all'

    // Get models for the requested mode
    const models = getAvailableModels(mode)

    // Add mode-specific information
    const response = {
      models,
      defaultModel: mode === 'all' ? 'claude-3-7-sonnet' : getDefaultModel(mode),
      agentModelNote: mode === 'agent' ? AGENT_MODEL_NOTE : null
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('[MODELS] Error fetching models:', error)
    return NextResponse.json(
      { error: 'Failed to fetch models' },
      { status: 500 }
    )
  }
}
"""
    
    # Update the API route
    api_route_path = project_root / 'app' / 'api' / 'models' / 'route.ts'
    api_route_path.write_text(api_models_content)
    
    print(f"‚úÖ Updated API route at {api_route_path}")
    
    return True

if __name__ == "__main__":
    print("üîÑ Syncing model configuration from backend to frontend...")
    print("="*50)
    
    if sync_models_to_frontend():
        print("\n‚úÖ Sync completed successfully!")
        print("\nüìù Next steps:")
        print("1. Update the frontend components to import from '@/lib/models-config'")
        print("2. The model dropdown will now show the correct models for each mode")
        print("3. Agent mode will only show Nova Micro with a note about the limitation")
    else:
        print("\n‚ùå Sync failed!") 